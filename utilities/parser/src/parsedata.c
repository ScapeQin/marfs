#include <string.h>
#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>

#ifdef DATAPARSE
#include "parse-inc/config-structs.h"							// generated by the pre-parse tool
#include "parse-inc/path-names.inc"								// generated by the pre-parse tool

#include "parse-types.h"

int configIdx(char *str)
{
int i=0, max_idx=sizeof(configFields)/sizeof(char *);                                   // counter....  and there are this many nested fields

while (i < max_idx)                                                                     // we only know of these many things
   if (strcmp(configFields[i++], str) == 0)                                             // Do we have a match?
      return --i;                                                                       // index of where this match is

return -1;                                                                              // I have no idea what you're talking about
}



void *memberSwitchParse(char *path, struct config *config, int sw_task) {
int field = configIdx(path);
char *val_buff;

switch(field) {										// switch to where we know what to do with this value
   #include "parse-inc/path-switch.inc"							// generated by the pre-parse tool
   default: return (void *)NULL; break;							// we don't have this member
   }
return (void *)NULL;									// return the index of what we know
}



void *getMemberPtr(char *path, struct config *config) {
return memberSwitchParse(path, config, GET_PTR);					// return pointer to struct or member/field
}



void *fMemberPtr(char *path, struct config *config) {
return memberSwitchParse(path, config, GET_F_PTR);					// return pointer to a member/field ONLY
}



struct line *freeConfigStructContent(struct config *cfg)
{
int i=0, max_idx=sizeof(configFields)/sizeof(char *);					// counter....  and there are this many nested fields
char **v_ptr;

for (i = 0; i < max_idx; i++) {								// we only know of this many paths
   v_ptr = (char **)fMemberPtr(configFields[i], cfg);					// get a void ptr to this member
   if (v_ptr != (char **)NULL) {							// it can be free'd else it's NULL
#ifdef DEBUG
      printf("Free-ing: %s -- %s\n", configFields[i], *v_ptr);				// DBG msg
#endif
      free(*v_ptr);									// free the space
      }
   }

return (struct line *)NULL;                                                             // I have no idea what you're talking about
}



void **listObjByName(char *objName, struct config *config)
{
int  max_idx=sizeof(configFields)/sizeof(char *);
int i, match = 0, ptr_cnt = 0;
char *c_ptr, *cb_ptr;
void **ptr_list;

ptr_list = (void **) malloc((max_idx +1) * sizeof(void *));			// create a list for possibly all objects plus one for the terminating spot
memset((void *)ptr_list, 0x00, (max_idx + 1)  * sizeof(void *));		// wipe the list clean

for (i = 0; i < max_idx; i++) {
   c_ptr = strstr(configFields[i], objName);
   if (c_ptr != (char *)NULL) {
      match = 0;
      c_ptr += strlen(objName);						// c_ptr is pointing at the position AFTER the last character
      if (c_ptr[0] == 0)
         match = 1;
      if (c_ptr[0] == '.')
         match = 1;
      if (c_ptr[0] == '[') {
         cb_ptr = strstr(c_ptr, "]");					// this is the first find, so closing for previous bracket
         if (cb_ptr != (char *)NULL) {
            cb_ptr += 1;						// point at position AFTER the string
            if (cb_ptr[0] == 0)
               match = 1;
            }
         }
      if (c_ptr[0] == '-')
         if (c_ptr[1] == '>')
            match = 1;
      if (match == 1) {
         ptr_list[ptr_cnt] = getMemberPtr(configFields[i], config);
         ptr_cnt++;
         ptr_list[ptr_cnt] = (void *)NULL;
         }
      }
   }
return ptr_list;
}
#endif
