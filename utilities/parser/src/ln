Binary file confpars matches
confpars.c:while (c_ptr->next != (struct line *)NULL && cnt >0) {							// as long as there are lines and we didn't find it yet
confpars.c:   if (strstr(c_ptr->ln, "};") != (char *)NULL)
confpars.c:   if (strstr(c_ptr->ln, "{")  != (char *)NULL)
confpars.c:   c_ptr = c_ptr->next;										// advance current pointer one position
confpars.c:n_ptr = c_ptr->next;										// next pointer pointing at line after the struct definition
confpars.c:   n_ptr = c_ptr->next;
confpars.c:while (c_ptr->next != h_struct)										// go to the line just before where the struct starts
confpars.c:   c_ptr = c_ptr->next;											// current pointer
confpars.c:n_ptr = c_ptr->next;											// next pointer pointing to the struct definition
confpars.c:   c_ptr->next = n_ptr->next;										// point at the struct after the one we're deleting
confpars.c:   n_ptr = c_ptr->next;
confpars.c:c_ptr->next = n_ptr->next;										// n_ptr is pointing a the closing line
confpars.c:printf("%s - %s\n", c_ptr->ln, c_ptr->dbg);
confpars.c:while (c_ptr->next != (struct line *)NULL && in_struct) {
confpars.c://while (c_ptr->next != (struct line *)NULL && in_struct && c_ptr < e_ptr) {
confpars.c:   c_ptr = c_ptr->next;											// walk down the list
confpars.c:printf("%s - %s\n", c_ptr->ln, c_ptr->dbg);								// move to the next line
confpars.c:   if (strstr(c_ptr->ln, "};") == (char *)NULL) {							// stop at the end of this structure
confpars.c:      if (strstr(c_ptr->ln, member) != (char *)NULL) {
confpars.c:while (c_ptr->next != (struct line *)NULL && in_struct) {						// as long as there are members in this struct
confpars.c:   c_ptr = c_ptr->next;											// move to the next line
confpars.c:   n_ptr = c_ptr->next;										// point to the line after the current line (could be NULL)
confpars.c:   if (strstr(c_ptr->ln, "};") == (char *)NULL) {							// stop at the end of this structure
confpars.c:      if (strstr(c_ptr->ln, srch_str) != (char *)NULL) {						// if this is the field/member we're looking for
confpars.c:         printf("Removing: '%s - %s' member\n", srch_str, c_ptr->ln);
confpars.c:while (c_ptr->next != (struct line *)NULL && in_struct) {						// as long as we're in this struct
confpars.c:   c_ptr = c_ptr->next;											// go to the next line
confpars.c:   if (strstr(c_ptr->ln, "};") == (char *)NULL)								// if we're not at the end of the struct
confpars.c:while (c_ptr->next != (struct line *)NULL && in_struct) {						// as long as we're in this struct
confpars.c:   c_ptr = c_ptr->next;											// go to the next line
confpars.c:   if (strstr(c_ptr->ln, "};") == (char *)NULL) {							// not the end of the struct yet
confpars.c:      st_ptr = strstr(c_ptr->ln, srch_str);
confpars.c:printf("List Counting:   %s\n", c_ptr->ln);
confpars.c:printf("Single Counting: %s\n", c_ptr->ln);
confpars.c:printf("%s\n", c_ptr->ln);
confpars.c:while (c_ptr->next != (struct line *)NULL && in_struct == 1) {
confpars.c:   c_ptr = c_ptr->next;
confpars.c:   printf("%s\n", c_ptr->ln);
confpars.c:   if (strstr(c_ptr->ln, "};") != (char *)NULL)
confpars.c:   while (c_ptr->next != (struct line *) NULL) {
confpars.c:      c_ptr   = c_ptr->next;										// base is never used except for attaching things to, go to next
confpars.c:printf("===%s\n", c_ptr->ln);
confpars.c:      if (c_ptr->lvl > order)										// if this recursion level was higher ...
confpars.c:         order = c_ptr->lvl;										//                                    ... take it
confpars.c:      while (c_ptr->next != (struct line *) NULL) {							// only end of the list should be NULL
confpars.c:         c_ptr = c_ptr->next;										// this is our 'current' line
confpars.c:         if (c_ptr->next != (struct line *)NULL)
confpars.c:            n_ptr = c_ptr->next;									// possible next line ...
confpars.c:         if (c_ptr->tag == 0) {										// if the line is not tagged, it's up for grabs
confpars.c:            if (c_ptr->lvl == i && c_ptr->ln != (char *)NULL) {						// it is the level we're looking for and there is a line
confpars.c:               if (c_ptr->lvl - p_ptr->lvl == 1) {							// level of previous line is one less, so it is our 'head'
confpars.c:if (strstr(c_ptr->ln, "struct config_") != (char *)NULL)
confpars.c:   printf("c_ptr->ln: %s\n", c_ptr->ln);
confpars.c:               c_ptr->tag = 1;										// this is our line, tag and take it
confpars.c:               printf("[%d] [%d] [%d] +2+ %s\n", c_ptr->lvl, c_ptr->tag, i, c_ptr->ln);		// print current header line
confpars.c:               new->ln = (char *)malloc(strlen(c_ptr->ln)+1);						// allocate for line
confpars.c:               strcpy(new->ln, c_ptr->ln);								// copy the string
confpars.c:   while (c_ptr->next != (struct line *) NULL) {
confpars.c:      c_ptr = c_ptr->next;
confpars.c:      if (c_ptr->ln != (char *)NULL) {
confpars.c:         strcpy(tmp_line, c_ptr->ln);
confpars.c:      while (c_ptr->next != (struct line *) NULL) {
confpars.c:         c_ptr = c_ptr->next;
confpars.c:         if (c_ptr->ln != (char *)NULL) {
confpars.c:            strcpy(tmp_line, c_ptr->ln);
confpars.c:   while (c_ptr->next != (struct line *) NULL) {
confpars.c:      c_ptr = c_ptr->next;
confpars.c:      if (c_ptr->ln != (char *)NULL)
confpars.c:         printf("[%d] [%d] %s %s\n", c_ptr->lvl, c_ptr->tag, c_ptr->dbg, c_ptr->ln);
confpars.c:while (c_ptr->next != (struct elmPathCnt *)NULL) {
confpars.c:   c_ptr = c_ptr->next;
confpars.c:   if (strcasecmp(c_ptr->elem, element) == 0) {
confpars.c:      c_ptr->cnt++;
confpars.c:      return c_ptr->cnt;
confpars.c:c_ptr->next = new;
confpars.c:return c_ptr->cnt;
confpars.c:while (c_ptr->next != (struct line *)NULL) {
confpars.c:   c_ptr = c_ptr->next;
path-switch.c:if (c_ptr->next == (struct line *)NULL)
path-switch.c:while (c_ptr->next != (struct line *)NULL) {
path-switch.c:   c_ptr = c_ptr->next;
path-switch.c:   while (c_ptr->next != (struct line *)NULL) {									// as long as there's a valid next
path-switch.c:      c_ptr = c_ptr->next;											// go to the next one
path-switch.c:         if (c_ptr->type == TYPE_CHAR) {									// we treat dynamic (char *) different than static structs
path-switch.c:            fprintf(fs_ptr, "   return (void *)&(%s);\n", c_ptr->ln);						// for (char *) just return the pointer
path-switch.c:         if (c_ptr->type == TYPE_STRUCT) {									// structs are static for now, we don't free/alloc them
path-switch.c:            fprintf(fs_ptr, "      return (void *)&(%s);\n", c_ptr->ln);					// return pointer for 'regular' addressing
path-switch.c:         fprintf(fn_ptr, "\"%s\"", c_ptr->ln);									// list of paths in the structure
